package tasks

import (
	"mediumkube/common"
	"mediumkube/utils"

	"github.com/coreos/go-iptables/iptables"
	"k8s.io/klog/v2"
)

// IPMode how rules are inserted into iptables
type IPMode int

const (
	table string = "filter"

	// IPModAPP appends rule to filter chain
	IPModAPP IPMode = 1
	// IPModPREP prepend
	IPModPREP IPMode = 2
)

var (
	ruleRegistry [][]string = make([][]string, 0)
)

func _forwardRuleIn(bridge common.Bridge) []string {
	return []string{
		"-s", bridge.Inet,
		"-i", bridge.Name,
		"-j", "ACCEPT",
	}
}

func _forwardRuleOut(bridge common.Bridge) []string {
	return []string{
		"-d", bridge.Inet,
		"-o", bridge.Name,
		"-m", "conntrack",
		"--ctstate", "RELATED,ESTABLISHED",
		"-j", "ACCEPT",
	}
}

func _forwardRuleIO(bridge common.Bridge) []string {
	return []string{
		"-i", bridge.Name,
		"-o", bridge.Name,
		"-j", "ACCEPT",
	}
}

func _forwardRejectICMPUnreachableIn(bridge common.Bridge) []string {
	return []string{
		"-i", bridge.Name,
		"-j", "REJECT",
		"--reject-with", "icmp-port-unreachable",
	}
}

func _forwardRejectICMPUnreachableOut(bridge common.Bridge) []string {
	return []string{
		"-o", bridge.Name,
		"-j", "REJECT",
		"--reject-with", "icmp-port-unreachable",
	}
}

func _dhcpIn(bridge common.Bridge) []string {
	return []string{
		"-i", bridge.Name,
		"-p", "udp",
		"-m", "udp",
		"--dport", "67",
		"-j", "ACCEPT",
	}
}

func _dhcpOut(bridge common.Bridge) []string {
	return []string{
		"-o", bridge.Name,
		"-p", "udp",
		"-m", "udp",
		"--sport", "67",
		"-j", "ACCEPT",
	}
}

func _dnsIn(bridge common.Bridge, protocol string) []string {
	return []string{
		"-i", bridge.Name,
		"-p", protocol,
		"-m", protocol,
		"--dport", "53",
		"-j", "ACCEPT",
	}
}

func _dnsOut(bridge common.Bridge, protocol string) []string {
	return []string{
		"-o", bridge.Name,
		"-p", protocol,
		"-m", protocol,
		"--dport", "53",
		"-j", "ACCEPT",
	}
}

func _forwardInboundToHost(bridge common.Bridge) []string {
	return []string{
		"-i", bridge.Name,
		"-o", bridge.Host,
		"-j", "ACCEPT",
	}
}

func _forwardOutboundExtablished(bridge common.Bridge) []string {
	return []string{
		"-o", bridge.Name,
		"-i", bridge.Host,
		"-m", "conntrack",
		"--ctstate", "ESTABLISHED,RELATED",
		"-j", "ACCEPT",
	}
}

func insertRuleIfNotExists(chain string, mode IPMode, rules ...string) {
	rules = append(rules, "-m", "comment", "--comment", "Auto generated by mediumkubed")
	if !utils.ContainsT(ruleRegistry, append([]string{chain}, rules...)) {
		ruleRegistry = append(ruleRegistry, append([]string{chain}, rules...))
	}
	iptable, err := iptables.New()
	if err != nil {
		klog.Error(err)
		return
	}

	exists, err := iptable.Exists(
		table,
		chain,
		rules...,
	)
	if err != nil {
		klog.Error(err)
		return
	}

	if !exists {
		klog.Info("Appending: ", rules)
		if mode == IPModAPP {
			iptable.Append(table, chain, rules...)

		} else if mode == IPModPREP {
			iptable.Insert(table, chain, 1, rules...)

		}
	}
}

// ProcessIptables configure netfilter rules required for DNS, DHCP and other applications
func ProcessIptables(bridge common.Bridge) {
	insertRuleIfNotExists("FORWARD", IPModPREP, _forwardRuleOut(bridge)...) // Allow outbound traffic from bridge
	insertRuleIfNotExists("FORWARD", IPModPREP, _forwardRuleIn(bridge)...)  // Allow inbound traffic to bridge
	insertRuleIfNotExists("FORWARD", IPModPREP, _forwardRuleIO(bridge)...)
	// insertRuleIfNotExists("FORWARD", _forwardInboundToHost(bridge)...)
	// insertRuleIfNotExists("FORWARD", _forwardOutboundExtablished(bridge)...)
	insertRuleIfNotExists("FORWARD", IPModAPP, _forwardRejectICMPUnreachableIn(bridge)...) // Reject traffic when ICMP unreachable
	insertRuleIfNotExists("FORWARD", IPModAPP, _forwardRejectICMPUnreachableOut(bridge)...)
	insertRuleIfNotExists("INPUT", IPModPREP, _dhcpIn(bridge)...) // Open port for DHCP
	insertRuleIfNotExists("INPUT", IPModPREP, _dnsIn(bridge, "tcp")...)
	insertRuleIfNotExists("INPUT", IPModPREP, _dnsIn(bridge, "udp")...)
	insertRuleIfNotExists("OUTPUT", IPModPREP, _dhcpOut(bridge)...)
	insertRuleIfNotExists("OUTPUT", IPModPREP, _dnsOut(bridge, "tcp")...)
	insertRuleIfNotExists("OUTPUT", IPModPREP, _dnsOut(bridge, "udp")...)
}

// CleanUpIptables clean up iptables when exiting
func CleanUpIptables() {
	iptable, err := iptables.New()
	if err != nil {
		klog.Error(err)
		return
	}
	for _, cr := range ruleRegistry {
		chain := cr[0]
		rules := cr[1:]
		exists, err := iptable.Exists(
			table,
			chain,
			rules...,
		)
		if err != nil {
			klog.Error(err)
			return
		}
		if exists {
			klog.Info("Deleting: ", rules)
			iptable.Delete(table, chain, rules...)
		}
	}
}
